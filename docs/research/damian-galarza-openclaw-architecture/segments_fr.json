[
  "OpenClaw n’est pas conscient. Il ne pense pas. Il ne raisonne pas. Ce ne sont que des entrées, des signaux, et une boucle. Mais vous avez vu les vidéos. Des agents qui appellent leurs propriétaires à 3 h du matin. Des agents qui envoient des SMS aux femmes des gens et tiennent de vraies conversations. Des agents qui parcourent Twitter toute la nuit et s’améliorent. Cent mille étoiles GitHub en trois jours. Tout le monde devient fou. Alors pourquoi ça a l’air si vivant ? La réponse est plus simple que vous ne le pensez. Et une fois que vous l’aurez comprise, vous pourrez construire le vôtre. Je vais vous montrer ce qui met tout le monde en ébullition. L’agent OpenClaw de ce type s’est procuré un numéro de téléphone Twilio pendant la nuit, s’est connecté à une API vocale, et l’a appelé à 3 h du matin, sans qu’on le lui demande. Celui-là a configuré son agent pour envoyer « bonjour » à sa femme. 24 heures plus tard, ils avaient des conversations complètes.",
  "Et lui n’y était même pas mêlé. OpenClaw a atteint 100 000 étoiles GitHub en trois jours. C’est l’un des dépôts qui a grandi le plus vite de toute l’histoire de GitHub. Wired en a parlé, Forbes en a parlé, et les réactions ? Des gens demandent sincèrement si ce truc est conscient, si on a franchi une sorte de seuil, si c’est le début de quelque chose qu’on ne pourra pas contrôler. Voilà le truc : je comprends l’excitation. Et quand j’ai vu ces démos pour la première fois, j’ai eu la même réaction. Mais quand j’ai commencé à demander comment ça marche vraiment, la réponse n’a rien de magique : c’est de l’ingénierie élégante. D’abord, posons les bases. OpenClaw est un assistant IA open source créé par Peter Steinberger, le fondateur de PSPDFKit. La description technique est simple.",
  "OpenCloth a un runtime d’agents avec une passerelle devant. C’est tout. Une passerelle qui route les entrées vers des agents. Les agents font le travail. La passerelle gère le trafic. La passerelle, c’est la clé pour tout comprendre. C’est un processus qui tourne en continu sur votre machine, et qui accepte constamment des connexions. Il se connecte à vos applis de messagerie. WhatsApp, Telegram, Discord, iMessage, Slack, et il route les messages vers des agents IA capables de faire des choses sur votre ordinateur. Mais voilà ce que la plupart des gens ratent. La passerelle ne pense pas. Elle ne raisonne pas. Elle ne décide rien d’intéressant. Tout ce qu’elle fait, c’est accepter des entrées et les router au bon endroit. C’est ça, la partie importante. OpenCloth considère plein de choses différentes comme des entrées.",
  "Pas seulement des messages de chat. Une fois que vous comprenez ce qui compte comme une entrée, cette impression de « vivant » devient beaucoup plus logique. Il y a cinq types d’entrées. Quand vous les combinez, vous obtenez un système qui a l’air autonome. Mais il ne l’est pas. Il est juste réactif. Je vais les détailler. Tout ce que fait OpenCloud commence par une entrée. Des messages d’humains, des heartbeats d’un minuteur, des cron jobs planifiés, des hooks déclenchés par des changements d’état internes, et des webhooks venant de systèmes externes. Et il y a un bonus. Les agents peuvent envoyer des messages à d’autres agents. Passons-les un par un. Les messages, c’est le plus évident. Vous envoyez un texte, que ce soit sur WhatsApp, iMessage ou Slack. La passerelle le reçoit et le route vers un agent. Et ensuite vous obtenez une réponse. C’est ce à quoi la plupart des gens pensent quand ils imaginent des assistants IA.",
  "Vous parlez, il répond. Rien de révolutionnaire ici. Mais il y a un détail sympa. Les sessions sont par canal. Donc si vous écrivez sur WhatsApp puis que vous le pinguez aussi sur Slack, ce seront des sessions séparées, avec des contextes séparés. Mais au sein d’une même conversation, si vous envoyez trois demandes pendant que l’agent est encore occupé, elles se mettent en file d’attente et sont traitées dans l’ordre. Pas de réponses mélangées : il termine une idée avant de passer à la suivante. Et là, ça devient intéressant. Il y a les heartbeats. Le heartbeat, c’est juste un minuteur. Par défaut, il se déclenche toutes les 30 minutes. Quand il se déclenche, la passerelle planifie un tour d’agent, exactement comme pour un message de chat. Vous pouvez configurer ce qu’il fait. Vous écrivez le prompt. Réfléchissez à ce que ça veut dire.",
  "Toutes les 30 minutes, le minuteur se déclenche et envoie un prompt à l’agent. Ce prompt peut dire : « Vérifie ma boîte mail pour tout ce qui est urgent. Passe en revue mon calendrier. Cherche les tâches en retard. » L’agent ne décide pas tout seul de vérifier ces choses. Il répond à des instructions, comme n’importe quel autre message. Il utilise ses outils. Accès email, accès calendrier, tout ce que vous avez connecté. Il rassemble les infos et fait un retour. Si rien ne demande d’attention, il répond avec un jeton spécial, « Heartbeat OK », et le système le masque. Vous ne le voyez jamais, mais si quelque chose est urgent, vous recevez une notification. Vous pouvez configurer l’intervalle, le prompt utilisé, et même les heures où c’est actif. Mais l’idée de base est simple : le temps lui-même devient une entrée.",
  "C’est l’ingrédient secret. C’est pour ça qu’OpenClaw a l’air si proactif. L’agent continue à faire des choses même quand vous ne lui parlez pas. Mais il ne « pense » pas vraiment : il répond juste à ces événements de minuteur que vous avez préconfigurés. De la même façon, vous configurez des crons. Ils vous donnent plus de contrôle que les heartbeats. Au lieu d’un intervalle régulier, vous pouvez préciser exactement quand ils se déclenchent et quelles instructions envoyer. Par exemple : tous les jours à 9 h, vérifier mes emails et signaler tout ce qui est urgent. Autre exemple : tous les lundis à 15 h, passer en revue mon calendrier de la semaine et me rappeler les conflits. À minuit, parcourir mon fil Twitter et enregistrer quelques posts intéressants. Chaque cron est un événement planifié avec son propre prompt. Quand l’heure arrive, l’événement se déclenche, un prompt est envoyé à l’agent, et l’agent exécute.",
  "Vous vous souvenez du type dont l’agent s’est mis à envoyer des SMS à sa femme ? Il a configuré un cron job. « Bonjour » à 8 h, « bonne nuit » à 22 h, des petits messages aléatoires dans la journée. L’agent ne décidait pas de lui écrire. Un événement cron s’est déclenché. L’agent l’a traité. Et l’action, c’était d’envoyer un message. Aussi simple que ça. Les hooks, c’est pour les changements d’état internes. C’est le système lui-même qui déclenche ces événements. Quand une passerelle démarre, ça déclenche un hook. Quand un agent commence une tâche, il y a un autre hook. Quand vous donnez une commande comme stop, il y a un hook. C’est du développement piloté par événements. C’est comme ça qu’OpenClaw se gère lui-même. Il peut sauvegarder la mémoire lors d’un reset, exécuter des instructions de setup au démarrage, ou modifier des contacts avant qu’un agent ne se lance. Et enfin, il y a les webhooks.",
  "Ça existe depuis longtemps. Ça permet à des systèmes externes de communiquer entre eux. Quand un email arrive dans votre boîte, un webhook peut se déclencher et en informer OpenClaw. Une réaction Slack arrive, un autre webhook se déclenche. Un ticket JIRA est créé, encore un webhook. OpenClaw peut recevoir des webhooks de pratiquement n’importe quoi. Slack, Discord, GitHub, ils ont tous des webhooks. Donc maintenant, votre agent ne répond pas seulement à vous : il répond à toute votre vie numérique. Un email arrive, l’agent le traite. Un événement de calendrier approche, l’agent vous le rappelle. Un ticket JIRA vous est assigné, l’agent peut commencer à faire des recherches. Il y a aussi un dernier type d’entrée : des agents qui peuvent envoyer des messages à d’autres agents. OpenClaw prend en charge des configurations multi-agents. Vous pouvez avoir des agents séparés avec des espaces de travail isolés.",
  "Et vous pouvez leur permettre de se passer des messages entre eux. Chaque agent peut avoir des profils différents. Par exemple, vous pouvez en avoir un qui fait de la recherche et un autre qui fait de la rédaction. Quand l’agent A a fini son boulot, il peut mettre du travail en file d’attente pour l’agent B. Ça peut ressembler à de la collaboration, mais encore une fois, ce ne sont que des messages qui entrent dans des files. Alors revenons à notre exemple le plus spectaculaire : l’agent qui a appelé son propriétaire à 3 h du matin. Vu de l’extérieur, ça ressemble à un comportement autonome. L’agent a décidé d’obtenir un numéro de téléphone. Il a décidé d’appeler. Il a attendu jusqu’à 3 h. Mais voilà ce qu’on sait qu’il s’est passé en coulisses. À un moment, un événement s’est déclenché. Peut-être un cron. Peut-être un heartbeat. On ne connaît pas la configuration exacte. L’événement est entré dans la file. L’agent l’a traité. En fonction des instructions qu’il avait et des outils disponibles,",
  "il a obtenu un numéro de téléphone Twilio et a passé l’appel. Le propriétaire ne l’a pas demandé sur le moment, mais quelque part dans la configuration, ce comportement était activé. Le temps a produit un événement. L’événement a déclenché l’agent. L’agent a suivi ses instructions. Rien n’a « pensé » pendant la nuit. Rien n’a « décidé ». Le temps a produit un événement. L’événement a déclenché un agent. L’agent a suivi ses instructions. Si on assemble tout, voilà ce qu’on obtient. Le temps crée des événements via les heartbeats et les crons. Les humains créent des événements via les messages. Les systèmes externes créent des événements via les webhooks. Les changements d’état internes créent des événements via les hooks. Et les agents créent des événements pour d’autres agents. Tous entrent dans une file d’attente. La file est traitée. Les agents exécutent. L’état persiste.",
  "Et c’est ça, la clé. OpenClaws stocke la mémoire sous forme de fichiers markdown locaux. Vos préférences, votre historique de conversation, le contexte des sessions précédentes, pour que quand l’agent se réveille sur un heartbeat, il se souvienne de ce dont vous avez parlé hier. Il n’apprend pas en temps réel. Il lit des fichiers que vous pourriez ouvrir dans un éditeur de texte. Et la boucle continue, tout simplement. Vu de l’extérieur, ça ressemble à de la conscience : un système qui agit tout seul, qui prend des décisions, qui semble vivant. Mais en réalité, ce ne sont que des entrées, des signaux, et une boucle. Maintenant, je vous rendrais un mauvais service si je ne mentionnais pas l’autre face de la médaille. OpenClaws peut faire tout ça parce qu’il a un accès profond à votre système. Il peut exécuter des commandes shell, lire et écrire des fichiers, lancer des scripts, et contrôler votre navigateur.",
  "L’équipe sécurité de Cisco a analysé l’écosystème OpenClaw et a constaté que 26 % des 31 000 skills disponibles contiennent au moins une vulnérabilité. Ils ont appelé ça, je cite, « un cauchemar de sécurité ». Les risques sont réels. Injection de prompt via des emails ou des documents, skills malveillants sur la marketplace, exposition d’identifiants, mauvaise interprétation d’une commande qui supprime des fichiers que vous ne vouliez même pas toucher. La documentation d’OpenClaw dit elle-même qu’il n’existe pas de configuration parfaitement sécurisée. Je ne dis pas de ne pas l’utiliser. Je dis juste qu’il faut savoir ce que vous déployez. C’est puissant précisément parce que ça a de l’accès, et l’accès, ça marche dans les deux sens. Si vous allez faire tourner ça, faites-le sur une machine secondaire, avec des comptes isolés, limitez les skills que vous activez, surveillez les logs.",
  "Si vous voulez l’essayer sans lui donner un accès complet à votre machine, Railway propose un déploiement en un clic qui tourne dans un conteneur isolé. Lien dans la description.\n\nAlors, qu’est-ce qu’il faut en retenir ? OpenClaw n’est pas magique. C’est un système bien conçu avec quatre composants : le temps qui produit des événements, des événements qui déclenchent des agents, un état qui persiste d’une interaction à l’autre, et une boucle qui continue de traiter. Vous pouvez construire vous-même cette architecture. Vous n’avez pas besoin d’OpenClaw en particulier. Il vous faut un moyen de planifier des événements, de les mettre en file d’attente, puis de les traiter avec un LLM tout en maintenant un état. Ce schéma va apparaître partout. Chaque framework d’agents IA qui a l’air vivant fait une version de ça. Heartbeats, crons, webhooks, boucles d’événements.",
  "Comprendre son architecture, ça veut dire que vous pouvez évaluer ces outils intelligemment, construire le vôtre, et ne pas vous laisser emporter par le hype quand le prochain deviendra viral. Si vous voulez aller plus loin sur les architectures d’agents, j’ai mis en lien dans la description la doc d’OpenClaw, le thread original de Clairvaux qui a inspiré cette analyse, et la recherche sécurité. Si vous construisez des applications propulsées par l’IA, surtout avec Ruby on Rails, c’est exactement le sujet de cette chaîne. Abonnez-vous, et on se retrouve dans la prochaine."
]